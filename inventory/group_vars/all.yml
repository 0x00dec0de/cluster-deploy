---
# Kubernetes version
# k8s_version: 1.5.6

# Helm package manager version
# helm_version: 2.3.1

# Golang compiller version
# go_version: 1.8.1

# Account name of remote user. Ansible will use this user account to ssh into
# the managed machines. The user must be able to use sudo without asking
# for password
k8s_ssh_user: dev

# SSH key that will be used to connect your VM instances
# Use this default value if you won't use special separate key for this purposes
# k8s_ssh_key: '{{ lookup("file", "{{ ansible_env.HOME }}/.ssh/id_rsa.pub") }}'

# It will be used as the Internal dns domain name if DNS is enabled.
# Services will be discoverable under
# <service-name>.<namespace>.svc.<domainname>.<clustername>, e.g.
# myservice.default.svc.k8s.cluster
k8s_domain_name: k8s
k8s_cluster_name: cluster
k8s_cluster_domain: '{{ k8s_domain_name }}.{{ k8s_cluster_name }}'

# Path to the Inventory hosts file
# It should be auto generated during the crating of VM inctances
k8s_inventory_file: '{{ inventory_dir }}/{{ k8s_cluster_name }}'

# Kubernetes master and services host names
k8s_master_name: master.your-domain-name
k8s_services_name: services.your-domain-name

# Docker registry host name
k8s_registry_name: registry.your-domain-name

# Charts server repository
# k8s_charts_repo: github.com/k8s-community/charts

# Country name which used in `C` attribute of certificates (`NL`,`RU`, etc)
ssl_country: country-name

# City name which used in `L` attribute of certificates
ssl_city: city-name

# Organization name which used in `O` attribute of certificates
ssl_org: organization-name

# Organization Unit name which used in `OU` attribute of certificates
ssl_division: organization-unit-name

# State name which used in `ST` attribute of certificates
ssl_state: state-name

# SSL base certificate name
# SSL folder and file names will use the same name
ssl_name: kubernetes

# Path to files with SSL certificates and keys
ssl_dir: /etc/ssl/kubernetes

# Flannel backend type (Options: gce, vxlan)
# k8s_flannel_backend: vxlan

# Kubernetes internal network for services.
# Kubernetes services will get fake IP addresses from this range.
# This range must not conflict with anything in your infrastructure. These
# addresses do not need to be routable and must just be an unused block of space.
k8s_services_network: 10.254.0.0/16

# IP address of kubernetes service
# Usually it's first address in services subnet
k8s_cluster_service_ip: 10.254.0.1

# IP address of Kube DNS
# It should be in range of services subnet
k8s_cluster_dns: 10.254.0.10

# Flannel internal overlay network. It will assign IP
# addresses from this range to individual pods.
# This network must be unused block of space.
# k8s_flannel_network: 10.20.0.0/16

# It should be an IP addresses range corresponed with zone, e.g.
# Western Europe Zone has 10.132.0.0/20 IP range
# Use default IP range for determined zone in most of all cases
# gce_instances_ip_range: 10.132.0.0/24

# The network determines what network traffic the instance can access
# Use auto generated network name in most of all cases
# k8s_network_name: '{{ k8s_domain_name }}'

# Assigns the instance an IPv4 address from the subnetworkâ€™s range.
# Use auto generated subnetwork name in most of all cases
# gce_subnet_name: '{{ gce_network_name }}-{{ k8s_cluster_name }}'

# Forwarding allows the instance to help route packets
# gce_ip_forward: true

# A region is a specific geographical location where you can run your resources.
# Each region has one or more zones.
# gce_instances_region: europe-west1

# A zone is an isolated location within a region.
# Resources that live in a zone, such as instances,
# are referred to as zonal resources
# gce_instances_zone: europe-west1-b

# Using of network storage
# If network storage disabled will use local disk for every requested claim 
# network_storage: true

# Name of GCE persistent disk
# gce_storage_name: pd-std

# Type of GCE storage, options: `slow`, `fast`
# gce_storage_type: slow

# Size of GCE persistent disk in Gb
# gce_storage_size: 100

# Kubernetes load balancer type, valid values: `gce`, `nginx`
# TODO: load balancer `gce`
k8s_lb_type: nginx 

# List of groups with VM instance names and machine types
# Instance groups let you organize VM instances or use them
# in a load-balancing backend service
# Nodes contain comma separated list of instance names.
# Names must start with a lowercase letter followed by up to 63 lowercase letters,
# numbers, or hyphens, and cannot end with a hyphen
# Predefined machine types are managed by Google Compute Engine:
# https://cloud.google.com/compute/docs/machine-types
gce_groups:
  - name: master
    type: n1-standard-1
    nodes:
      - k8s-master-01
  - name: node
    type: n1-standard-2
    nodes:
      - k8s-node-01
      - k8s-node-02
      - k8s-node-03
  - name: build
    type: n1-standard-1
    nodes:
      - k8s-build-01

# Each instance requires a disk to boot from.
# Specify an image when you create an instance.
# List of predefined images you can find in this reference
# https://cloud.google.com/compute/docs/images
gce_image: centos-7

# You can choose to specify a startup script that will run when your instance
# boots up or restarts. Startup scripts can be used to install software and updates,
# and to ensure that services are running within the virtual machine.
# Learn more: https://cloud.google.com/compute/docs/startupscript
gce_startup_script: |
  #!/bin/bash

  yum update -y

# Select the type and level of API access to grant the VM.
# Default: read-only access to Storage and Service Management,
# write access to Stackdriver Logging and Monitoring,
# read/write access to Service Control.
# gce_sa_permissions:
#   - compute-rw
#   - logging-write
#   - monitoring-write
#   - service-control
#   - service-management
#   - storage-full
#   - useraccounts-ro

# Log level 0 - debug
# k8s_log_level: 2

# Users access data
k8s_admin_token: 'Admin user token should be here'
k8s_admin_username: admin
k8s_admin_password: 'password'
k8s_release_token: 'Release user token should be here'
k8s_release_username: release
k8s_release_password: 'password'
k8s_guest_token: 'Guest user token should be here'
k8s_guest_username: guest
k8s_guest_password: 'password'

# Docker registry secrets
# docker run --rm --entrypoint htpasswd registry:2 -Bbn <user> <password> | base64
k8s_docker_registry_token: 'docker registry token here'
# creates docker config with auth info
#
# Solution 1:
# (without login to docker registry)
# kubectl create secret docker-registry my-secret --docker-username=user --docker-password='password' \
# --docker-email 'docker@docker.com' --docker-server=<docker_registry_host> --dry-run -o yaml
# echo '<security_encoded_hash>' | base64 --decode
# create `.docker/config.json`
# {
#   "auths": {
#     "<docker_registry_host>": {
#       "auth": "<auth_info_from_previous_command>"
#     }
#   }
# }
# cat .docker/config.json | base64
#
# Solution 2:
# (need real login to docker registry)
# docker login -u=<user> -p=<password> <docker_registry_host:port>
# cat .docker/config.json | base64
k8s_docker_registry_auth_code: 'docker registry auth code here'
k8s_docker_registry_auth_token: 'docker registry auth config token'

# SSL certificate and private key for running user services into Kubernetes
k8s_services_cert: |
  ----BEGIN CERTIFICATE----
  - Your certificate here -
  -----END CERTIFICATE-----
k8s_services_cert_key: |
  ----BEGIN PRIVATE KEY----
  - Your private key here -
  -----END PRIVATE KEY-----

# A service account's credentials include a generated email address that is unique.
# Specify the email address of the user account
# You can create one according to the procedure specified in this reference
# https://developers.google.com/identity/protocols/OAuth2ServiceAccount#creatinganaccount
gce_service_account_email: '...-compute@developer.gserviceaccount.com'

# The full path of your unique service account credentials file. 
# Details on generating this can be found at
# https://docs.ansible.com/ansible/guide_gce.html#credentials
# You can download json credentials according to the procedure specified in this reference
# https://support.google.com/cloud/answer/6158849?hl=en&ref_topic=6262490#serviceaccounts
gce_credentials_file: '{{ ansible_env.HOME }}/gcloud.json'

# Specify your project ID which one used from your GCP account
gce_project_id: my-project-id
